#!/usr/bin/env bash

set -euo pipefail

# Default values
COMMAND=""
SPEC_FILE=""
DEBUG=${DEBUG:-0}
INTERACTIVE=true
AI_ASSIST=false
AI_PROMPT=""
TEMPLATE=""
VALIDATE=true
NO_BACKUP=false
VERSION_BUMP=""
CHANGELOG_MESSAGE=""
FORK_SOURCE=""
NEW_ID=""
NEW_TITLE=""
TEST_AI=false
USE_STDIN=false

# Semantic version regex
VERSION_REGEX="^[0-9]+\.[0-9]+\.[0-9]+$"

# Model preference based on spec-validator
MODEL_PREFERENCE=("claude-3-5-sonnet-20241022" "gpt-4o-2024-08-06" "gpt-4-turbo-2024-04-09")

usage() {
    cat << 'EOF'
Usage: spec-editor <command> [OPTIONS] <spec_file>

COMMANDS:
    create          Create a new spec file
    update          Update an existing spec file
    fork            Create a new spec based on existing one
    --test-ai       Test AI integration

CREATE OPTIONS:
    --template=TYPE     Use template (service, library, cli-tool, api-endpoint)
    --ai-prompt=TEXT    Generate content from description
    --ai-assist         Use AI to enhance content
    --stdin             Read description from stdin
    --id=ID             Set spec ID
    --title=TITLE       Set spec title
    --no-validate       Skip validation before save

UPDATE OPTIONS:
    --patch             Patch version bump (x.x.X)
    --minor             Minor version bump (x.X.0)
    --major             Major version bump (X.0.0)
    --changelog=MSG     Changelog message
    --ai-changelog      Generate changelog with AI
    --no-backup         Don't create backup file

FORK OPTIONS:
    --id=NEW_ID         ID for forked spec
    --title=NEW_TITLE   Title for forked spec
    --modify            Interactive modification after fork

GLOBAL OPTIONS:
    --no-interactive    Non-interactive mode
    --debug             Enable debug output
    -h, --help          Show this help message

REQUIRED:
    Either ANTHROPIC_API_KEY or OPENAI_API_KEY environment variable must be set.

EXAMPLES:
    # Interactive spec creation
    spec-editor create my-feature.md

    # Create from template
    spec-editor create --template=service --id=user-service user-service.md

    # Create with AI assistance
    echo "API rate limiter with Redis" | spec-editor create --stdin --ai-assist rate-limiter.md

    # Update with patch version
    spec-editor update --patch --changelog="Fixed typos" my-spec.md

    # Fork existing spec
    spec-editor fork base-spec.md new-spec.md --id=new-feature

    # Test AI integration
    spec-editor --test-ai "user authentication system"
EOF
    exit 1
}

error() {
    echo "Error: $1" >&2
    exit 1
}

debug() {
    if [[ "$DEBUG" == "1" ]]; then
        echo "[DEBUG] $1" >&2
    fi
}

# Parse command line arguments
if [[ $# -eq 0 ]]; then
    usage
fi

# Parse command first
case "$1" in
    create|update|fork)
        COMMAND="$1"
        shift
        ;;
    --test-ai)
        TEST_AI=true
        shift
        if [[ $# -gt 0 ]]; then
            AI_PROMPT="$1"
            shift
        fi
        ;;
    -h|--help)
        usage
        ;;
    *)
        error "Unknown command: $1. Use -h for help."
        ;;
esac

# Parse remaining options
while [[ $# -gt 0 ]]; do
    case $1 in
        --template=*)
            TEMPLATE="${1#*=}"
            shift
            ;;
        --ai-prompt=*)
            AI_PROMPT="${1#*=}"
            AI_ASSIST=true
            shift
            ;;
        --ai-assist)
            AI_ASSIST=true
            shift
            ;;
        --stdin)
            USE_STDIN=true
            shift
            ;;
        --id=*)
            NEW_ID="${1#*=}"
            shift
            ;;
        --title=*)
            NEW_TITLE="${1#*=}"
            shift
            ;;
        --no-validate)
            VALIDATE=false
            shift
            ;;
        --patch)
            VERSION_BUMP="patch"
            shift
            ;;
        --minor)
            VERSION_BUMP="minor"
            shift
            ;;
        --major)
            VERSION_BUMP="major"
            shift
            ;;
        --changelog=*)
            CHANGELOG_MESSAGE="${1#*=}"
            shift
            ;;
        --ai-changelog)
            AI_ASSIST=true
            shift
            ;;
        --no-backup)
            NO_BACKUP=true
            shift
            ;;
        --no-interactive)
            INTERACTIVE=false
            shift
            ;;
        --modify)
            # For fork command
            shift
            ;;
        --debug)
            DEBUG=1
            shift
            ;;
        -h|--help)
            usage
            ;;
        -*)
            error "Unknown option: $1"
            ;;
        *)
            if [[ "$COMMAND" == "fork" ]] && [[ -z "$FORK_SOURCE" ]]; then
                FORK_SOURCE="$1"
            else
                SPEC_FILE="$1"
            fi
            shift
            ;;
    esac
done

# Check for API keys
API_TYPE=""
API_KEY=""
if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
    API_TYPE="anthropic"
    API_KEY="$ANTHROPIC_API_KEY"
elif [[ -n "${OPENAI_API_KEY:-}" ]]; then
    API_TYPE="openai"
    API_KEY="$OPENAI_API_KEY"
else
    error "Either ANTHROPIC_API_KEY or OPENAI_API_KEY must be set"
fi

debug "API Type: $API_TYPE"

# Create a temporary directory (working directory, not system /tmp)
TMP_DIR="./tmp_spec_editor_$$"
mkdir -p "$TMP_DIR"
trap "rm -rf $TMP_DIR" EXIT

# Read the reference spec validator spec
SPEC_VALIDATOR_SPEC_PATH="$(dirname "$0")/../specs/spec-validator.md"
if [[ ! -f "$SPEC_VALIDATOR_SPEC_PATH" ]]; then
    error "Reference spec validator specification not found at: $SPEC_VALIDATOR_SPEC_PATH"
fi
SPEC_VALIDATOR_SPEC=$(cat "$SPEC_VALIDATOR_SPEC_PATH")

# Function to call OpenAI API
call_openai() {
    local model="$1"
    local prompt="$2"
    local system_message="$3"
    debug "Calling OpenAI API with model: $model"
    
    # Escape the prompt content using jq
    local escaped_prompt
    escaped_prompt=$(echo "$prompt" | jq -Rs .)
    
    # Create the request JSON
    cat > "$TMP_DIR/request.json" <<EOF
{
  "model": "$model",
  "messages": [
    {
      "role": "system",
      "content": "$system_message"
    },
    {
      "role": "user",
      "content": $escaped_prompt
    }
  ],
  "temperature": 0.3
}
EOF
    
    local response
    response=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_KEY" \
        -d @"$TMP_DIR/request.json")
    
    debug "OpenAI response received"
    
    # Check for errors
    if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        debug "OpenAI API error: $(echo "$response" | jq -r '.error.message')"
        return 1
    fi
    
    # Extract the content
    local content
    content=$(echo "$response" | jq -r '.choices[0].message.content // empty')
    if [[ -z "$content" ]]; then
        debug "Empty content from OpenAI response"
        return 1
    fi
    echo "$content"
}

# Function to call Anthropic API
call_anthropic() {
    local model="$1"
    local prompt="$2"
    local system_message="$3"
    debug "Calling Anthropic API with model: $model"
    
    # Escape the prompt content using jq
    local escaped_prompt
    escaped_prompt=$(echo "$system_message

$prompt" | jq -Rs .)
    
    # Create the request JSON
    cat > "$TMP_DIR/request.json" <<EOF
{
  "model": "$model",
  "max_tokens": 4096,
  "messages": [
    {
      "role": "user",
      "content": $escaped_prompt
    }
  ]
}
EOF
    
    local response
    response=$(curl -s -X POST https://api.anthropic.com/v1/messages \
        -H "Content-Type: application/json" \
        -H "x-api-key: $API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d @"$TMP_DIR/request.json")
    
    debug "Anthropic response received"
    
    # Check for errors
    if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        debug "Anthropic API error: $(echo "$response" | jq -r '.error.message')"
        return 1
    fi
    
    # Extract the content
    echo "$response" | jq -r '.content[0].text // empty'
}

# Function to call LLM with model preference
call_llm() {
    local prompt="$1"
    local system_message="${2:-You are a helpful assistant that creates structured specification documents.}"
    
    for model in "${MODEL_PREFERENCE[@]}"; do
        debug "Trying model: $model"
        
        local result=""
        # Skip models that don't match the API type
        if [[ "$API_TYPE" == "anthropic" ]] && [[ "$model" == claude* ]]; then
            if result=$(call_anthropic "$model" "$prompt" "$system_message" 2>/dev/null) && [[ -n "$result" ]]; then
                debug "Successfully used model: $model"
                echo "$result"
                return 0
            fi
        elif [[ "$API_TYPE" == "openai" ]] && [[ "$model" == gpt* ]]; then
            if result=$(call_openai "$model" "$prompt" "$system_message" 2>/dev/null) && [[ -n "$result" ]]; then
                debug "Successfully used model: $model"
                echo "$result"
                return 0
            fi
        fi
        debug "Model $model failed or incompatible with API type $API_TYPE"
    done
    
    error "Failed to get response from any compatible model"
}

# Function to validate spec using spec-validator
validate_spec() {
    local spec_file="$1"
    local validator_path="$(dirname "$0")/spec-validator"
    
    if [[ ! -f "$validator_path" ]]; then
        debug "Spec validator not found, skipping validation"
        return 0
    fi
    
    debug "Validating spec: $spec_file"
    if "$validator_path" "$spec_file" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Function to create backup
create_backup() {
    local file="$1"
    if [[ "$NO_BACKUP" == "true" ]]; then
        return 0
    fi
    
    if [[ -f "$file" ]]; then
        local backup_file="${file}.bak"
        cp "$file" "$backup_file"
        debug "Backup created: $backup_file"
    fi
}

# Function to prompt for input with default
prompt_input() {
    local prompt_text="$1"
    local default_value="${2:-}"
    local result=""
    
    if [[ "$INTERACTIVE" == "true" ]]; then
        if [[ -n "$default_value" ]]; then
            read -p "$prompt_text [$default_value]: " result
            result="${result:-$default_value}"
        else
            read -p "$prompt_text: " result
        fi
    else
        result="$default_value"
    fi
    
    echo "$result"
}

# Function to get current timestamp
get_timestamp() {
    date '+%Y-%m-%d'
}

# Function to increment version
increment_version() {
    local current_version="$1"
    local bump_type="$2"
    
    if [[ ! "$current_version" =~ $VERSION_REGEX ]]; then
        error "Invalid version format: $current_version"
    fi
    
    IFS='.' read -r major minor patch <<< "$current_version"
    
    case "$bump_type" in
        patch)
            ((patch++))
            ;;
        minor)
            ((minor++))
            patch=0
            ;;
        major)
            ((major++))
            minor=0
            patch=0
            ;;
        *)
            error "Invalid bump type: $bump_type"
            ;;
    esac
    
    echo "$major.$minor.$patch"
}

# Function to parse frontmatter
parse_frontmatter() {
    local file="$1"
    local field="$2"
    
    if [[ ! -f "$file" ]]; then
        return 1
    fi
    
    # Extract frontmatter between --- lines and get specific field
    awk '/^---$/ {flag=!flag; next} flag && /^'"$field"':/ {sub(/^'"$field"': */, ""); print; exit}' "$file"
}

# Function to generate spec template
generate_spec_template() {
    local spec_id="$1"
    local title="$2"
    local version="$3"
    local description="$4"
    local entry_points="$5"
    local status="${6:-draft}"
    
    cat << EOF
---
id: $spec_id
version: $version
title: $title
status: $status
entry_points:
  - $entry_points
description: >
  $description
---

## 🧠 Goal

[Describe the main purpose and objective of this specification]

## ⚙️ Functionality

[List the key features and capabilities]

## ✅ Success Criteria

[Define measurable success criteria]

## 🔐 Security

[Document security considerations if applicable]

## 🧪 Test Strategy

[Define testing approach and coverage requirements]

## 🛠️ Implementation Notes

[Include technical details and guidance]

## 📝 Example Usage

[Provide concrete examples of how this spec is used]

## 🔁 Changelog

- **$version** — $(get_timestamp) — Initial specification
EOF
}

# Handle test AI mode
if [[ "$TEST_AI" == "true" ]]; then
    echo "=== AI Integration Test ==="
    echo "API Type: $API_TYPE"
    echo "Available Models: ${MODEL_PREFERENCE[*]}"
    
    test_prompt="${AI_PROMPT:-A simple user authentication system}"
    echo "Test Prompt: $test_prompt"
    echo
    
    system_msg="You are a helpful assistant. Generate a brief 2-3 sentence description of a software specification for: $test_prompt"
    
    echo "Testing AI response..."
    result=$(call_llm "$test_prompt" "$system_msg")
    
    echo "Status: SUCCESS"
    echo "Response Length: $(echo "$result" | wc -c) characters"
    echo
    echo "AI Response:"
    echo "------------"
    echo "$result"
    echo "------------"
    exit 0
fi

# Handle create command
if [[ "$COMMAND" == "create" ]]; then
    if [[ -z "$SPEC_FILE" ]]; then
        error "Spec file path is required for create command"
    fi
    
    if [[ -f "$SPEC_FILE" ]]; then
        error "File already exists: $SPEC_FILE"
    fi
    
    echo "[SPEC EDITOR] Creating new spec: $SPEC_FILE"
    echo
    
    # Get input description if using stdin
    if [[ "$USE_STDIN" == "true" ]]; then
        AI_PROMPT=$(cat)
        AI_ASSIST=true
    fi
    
    # Collect spec information
    if [[ -n "$NEW_ID" ]]; then
        spec_id="$NEW_ID"
    else
        spec_id=$(prompt_input "Enter spec ID (lowercase-hyphenated)" "$(basename "$SPEC_FILE" .md)")
    fi
    
    if [[ -n "$NEW_TITLE" ]]; then
        title="$NEW_TITLE"
    else
        title=$(prompt_input "Enter title" "")
    fi
    
    version=$(prompt_input "Enter initial version" "0.1.0")
    
    # AI-enhanced description if requested
    if [[ "$AI_ASSIST" == "true" ]] && [[ -n "$AI_PROMPT" ]]; then
        echo "Generating description with AI..."
        ai_system="You are a technical specification writer. Generate a concise description (1-2 sentences) for a specification about: $AI_PROMPT. Focus on the core functionality and purpose."
        description=$(call_llm "$AI_PROMPT" "$ai_system")
    else
        description=$(prompt_input "Enter description" "")
    fi
    
    entry_points=$(prompt_input "Enter entry points (comma-separated)" "")
    
    if [[ "$INTERACTIVE" == "true" ]]; then
        echo
        echo "Select status:"
        echo "1) draft (new/experimental)"
        echo "2) active (in production)"
        echo "3) deprecated (being phased out)"
        status_choice=$(prompt_input "Choice" "1")
        
        case "$status_choice" in
            1) status="draft" ;;
            2) status="active" ;;
            3) status="deprecated" ;;
            *) status="draft" ;;
        esac
    else
        status="draft"
    fi
    
    # Generate the spec content
    spec_content=$(generate_spec_template "$spec_id" "$title" "$version" "$description" "$entry_points" "$status")
    
    # Enhance with AI if requested
    if [[ "$AI_ASSIST" == "true" ]] && [[ -n "$AI_PROMPT" ]]; then
        echo "Enhancing spec content with AI..."
        
        ai_enhance_prompt="Based on this description: '$AI_PROMPT'

Please enhance this specification template by filling in the placeholder sections with relevant content. Keep the structure and formatting intact, but replace the bracketed placeholder text with specific, relevant content.

Template to enhance:
$spec_content

Focus on:
- Goal section: Clear objective
- Functionality: Key features
- Success Criteria: Measurable outcomes
- Test Strategy: Appropriate testing approach

Respond with the complete enhanced specification document."
        
        enhanced_content=$(call_llm "$ai_enhance_prompt" "You are a technical specification writer. Enhance the provided template with relevant, specific content while maintaining the exact structure and formatting.")
        
        if [[ -n "$enhanced_content" ]]; then
            spec_content="$enhanced_content"
        fi
    fi
    
    # Write the file
    echo "$spec_content" > "$SPEC_FILE"
    
    # Validate if requested
    if [[ "$VALIDATE" == "true" ]]; then
        if validate_spec "$SPEC_FILE"; then
            echo "Spec created successfully! Validation passed."
        else
            echo "Warning: Spec created but validation failed. Run 'spec-validator $SPEC_FILE' to see issues."
        fi
    else
        echo "Spec created successfully!"
    fi
    
    echo "File: $SPEC_FILE"
    exit 0
fi

# Handle update command
if [[ "$COMMAND" == "update" ]]; then
    if [[ -z "$SPEC_FILE" ]]; then
        error "Spec file path is required for update command"
    fi
    
    if [[ ! -f "$SPEC_FILE" ]]; then
        error "Spec file not found: $SPEC_FILE"
    fi
    
    echo "[SPEC EDITOR] Updating: $SPEC_FILE"
    
    # Create backup
    create_backup "$SPEC_FILE"
    
    # Parse current version
    current_version=$(parse_frontmatter "$SPEC_FILE" "version")
    if [[ -z "$current_version" ]]; then
        error "Could not find version in spec file"
    fi
    
    echo "Current version: $current_version"
    
    # Determine version bump
    if [[ -z "$VERSION_BUMP" ]] && [[ "$INTERACTIVE" == "true" ]]; then
        echo
        echo "What type of change?"
        echo "1) Patch (typo/clarification)"
        echo "2) Minor (new feature/backwards compatible)"
        echo "3) Major (breaking change)"
        bump_choice=$(prompt_input "Choice" "1")
        
        case "$bump_choice" in
            1) VERSION_BUMP="patch" ;;
            2) VERSION_BUMP="minor" ;;
            3) VERSION_BUMP="major" ;;
            *) VERSION_BUMP="patch" ;;
        esac
    elif [[ -z "$VERSION_BUMP" ]]; then
        VERSION_BUMP="patch"
    fi
    
    # Calculate new version
    new_version=$(increment_version "$current_version" "$VERSION_BUMP")
    echo "New version: $new_version"
    
    # Get changelog message
    if [[ -z "$CHANGELOG_MESSAGE" ]]; then
        CHANGELOG_MESSAGE=$(prompt_input "Describe your change for the changelog" "")
    fi
    
    # Update version in file
    sed -i.tmp "s/^version: .*/version: $new_version/" "$SPEC_FILE"
    rm -f "${SPEC_FILE}.tmp"
    
    # Add changelog entry
    timestamp=$(get_timestamp)
    new_changelog_entry="- **$new_version** — $timestamp — $CHANGELOG_MESSAGE"
    
    # Find and update changelog section
    if grep -q "## 🔁 Changelog" "$SPEC_FILE"; then
        # Insert after changelog header
        awk -v new_entry="$new_changelog_entry" '
            /^## 🔁 Changelog/ {
                print
                print ""
                print new_entry
                next
            }
            {print}
        ' "$SPEC_FILE" > "$TMP_DIR/updated_spec.md"
        mv "$TMP_DIR/updated_spec.md" "$SPEC_FILE"
    else
        # Add changelog section at the end
        echo "" >> "$SPEC_FILE"
        echo "## 🔁 Changelog" >> "$SPEC_FILE"
        echo "" >> "$SPEC_FILE"
        echo "$new_changelog_entry" >> "$SPEC_FILE"
    fi
    
    echo
    echo "Summary of changes:"
    echo "- Version: $current_version → $new_version"
    echo "- New changelog entry"
    
    if [[ "$INTERACTIVE" == "true" ]]; then
        confirm=$(prompt_input "Confirm update? [y/N]" "n")
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            # Restore from backup
            if [[ -f "${SPEC_FILE}.bak" ]]; then
                mv "${SPEC_FILE}.bak" "$SPEC_FILE"
            fi
            echo "Update cancelled."
            exit 0
        fi
    fi
    
    # Validate if requested
    if [[ "$VALIDATE" == "true" ]]; then
        if validate_spec "$SPEC_FILE"; then
            echo "Updated successfully! Validation passed."
        else
            echo "Warning: Update completed but validation failed. Run 'spec-validator $SPEC_FILE' to see issues."
        fi
    else
        echo "Updated successfully!"
    fi
    
    exit 0
fi

# Handle fork command
if [[ "$COMMAND" == "fork" ]]; then
    if [[ -z "$FORK_SOURCE" ]] || [[ -z "$SPEC_FILE" ]]; then
        error "Both source and target files required for fork command"
    fi
    
    if [[ ! -f "$FORK_SOURCE" ]]; then
        error "Source spec file not found: $FORK_SOURCE"
    fi
    
    if [[ -f "$SPEC_FILE" ]]; then
        error "Target file already exists: $SPEC_FILE"
    fi
    
    echo "[SPEC EDITOR] Forking: $FORK_SOURCE → $SPEC_FILE"
    
    # Copy source file
    cp "$FORK_SOURCE" "$SPEC_FILE"
    
    # Update ID and title if specified
    if [[ -n "$NEW_ID" ]]; then
        sed -i.tmp "s/^id: .*/id: $NEW_ID/" "$SPEC_FILE"
        rm -f "${SPEC_FILE}.tmp"
    fi
    
    if [[ -n "$NEW_TITLE" ]]; then
        sed -i.tmp "s/^title: .*/title: $NEW_TITLE/" "$SPEC_FILE"
        rm -f "${SPEC_FILE}.tmp"
    fi
    
    # Reset version to 0.1.0
    sed -i.tmp "s/^version: .*/version: 0.1.0/" "$SPEC_FILE"
    rm -f "${SPEC_FILE}.tmp"
    
    # Reset changelog
    timestamp=$(get_timestamp)
    new_changelog="- **0.1.0** — $timestamp — Forked from $FORK_SOURCE"
    
    if grep -q "## 🔁 Changelog" "$SPEC_FILE"; then
        # Replace changelog section
        awk -v new_entry="$new_changelog" '
            /^## 🔁 Changelog/ {
                print
                print ""
                print new_entry
                in_changelog = 1
                next
            }
            /^## / && in_changelog {
                in_changelog = 0
            }
            !in_changelog {print}
        ' "$SPEC_FILE" > "$TMP_DIR/forked_spec.md"
        mv "$TMP_DIR/forked_spec.md" "$SPEC_FILE"
    fi
    
    echo "Fork created successfully!"
    echo "File: $SPEC_FILE"
    
    # Validate if requested
    if [[ "$VALIDATE" == "true" ]]; then
        if validate_spec "$SPEC_FILE"; then
            echo "Validation passed."
        else
            echo "Warning: Validation failed. Run 'spec-validator $SPEC_FILE' to see issues."
        fi
    fi
    
    exit 0
fi

error "Unknown command: $COMMAND"