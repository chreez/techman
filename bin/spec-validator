#!/usr/bin/env bash

set -euo pipefail

# Color codes for output
RED='\033[0;31m'
YELLOW='\033[0;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Default values
JSON_OUTPUT=false
DIFF_MODE=false
DIFF_FILE=""
ROOT_SPEC_FILE=""
MODEL_PREFERENCE=("claude-3-5-sonnet-20241022" "gpt-4o-2024-08-06" "gpt-4-turbo-2024-04-09")

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS] <spec_file>
       $0 [OPTIONS] --diff <diff_file> <root_spec_file>

Validates a spec file against the core spec-validator logic using Claude or OpenAI APIs.

OPTIONS:
    --json          Output results in JSON format
    --diff <file>   Validate only the diff content (use '-' for stdin)
                    When using --diff, a root spec file is REQUIRED for context
    -h, --help      Show this help message

REQUIRED:
    Either ANTHROPIC_API_KEY or OPENAI_API_KEY environment variable must be set.

EXAMPLES:
    $0 specs/example.md
    $0 --json specs/example.md > result.json
    git diff --cached specs/ | $0 --diff - specs/target-spec.md
    $0 --diff changes.patch specs/my-feature.md
EOF
    exit 1
}

# Error handling
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        --diff)
            DIFF_MODE=true
            DIFF_FILE="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        -*)
            error "Unknown option: $1"
            ;;
        *)
            if [[ "$DIFF_MODE" == true ]] && [[ -z "$ROOT_SPEC_FILE" ]]; then
                ROOT_SPEC_FILE="$1"
            else
                SPEC_FILE="$1"
            fi
            shift
            ;;
    esac
done

# Validate required inputs
if [[ "$DIFF_MODE" == true ]]; then
    if [[ -z "$DIFF_FILE" ]]; then
        error "Diff file required when using --diff mode"
    fi
    if [[ -z "$ROOT_SPEC_FILE" ]]; then
        error "Root spec file is REQUIRED when using --diff mode to provide complete validation context"
    fi
    if [[ ! -f "$ROOT_SPEC_FILE" ]]; then
        error "Root spec file not found: $ROOT_SPEC_FILE"
    fi
else
    if [[ -z "${SPEC_FILE:-}" ]]; then
        error "Spec file path is required"
    fi
    if [[ ! -f "$SPEC_FILE" ]]; then
        error "Spec file not found: $SPEC_FILE"
    fi
fi

# Check for API keys
if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
    API_TYPE="anthropic"
    API_KEY="$ANTHROPIC_API_KEY"
elif [[ -n "${OPENAI_API_KEY:-}" ]]; then
    API_TYPE="openai"
    API_KEY="$OPENAI_API_KEY"
else
    error "Either ANTHROPIC_API_KEY or OPENAI_API_KEY must be set"
fi

# Read the spec content
if [[ "$DIFF_MODE" == true ]]; then
    if [[ "$DIFF_FILE" == "-" ]]; then
        DIFF_CONTENT=$(cat)
    else
        DIFF_CONTENT=$(cat "$DIFF_FILE")
    fi
    
    # Extract spec file paths from diff and verify they match our root file
    SPEC_FILES=$(echo "$DIFF_CONTENT" | awk '/^(diff --git|---|\+\+\+)/ && /\.(md|yaml|yml)/ {
        gsub(/^(diff --git a\/|---|\\+\\+\\+\s+[ab]\/)/, "");
        print
    }' | sort -u)
    
    if [[ -z "$SPEC_FILES" ]]; then
        error "No spec files found in diff"
    fi
    
    # Read the root spec file for context
    ROOT_CONTENT=$(cat "$ROOT_SPEC_FILE")
    
    # Combine root file content with diff for complete context
    SPEC_CONTENT="Original spec file content:
$ROOT_CONTENT

Changes being validated (from diff):
$DIFF_CONTENT"
else
    SPEC_CONTENT=$(cat "$SPEC_FILE")
fi

# Read the reference spec validator spec
SPEC_VALIDATOR_SPEC=$(cat "$(dirname "$0")/../specs/spec-validator.md")

# Read the prompt template
PROMPT_TEMPLATE=$(cat "$(dirname "$0")/../scripts/promptTemplate-GPT.sh")

# Create a temporary directory for the request (working directory, not system /tmp)
TMP_DIR="./tmp_spec_validator_$$"
mkdir -p "$TMP_DIR"
trap "rm -rf $TMP_DIR" EXIT

# Prepare the full prompt
FULL_PROMPT="$PROMPT_TEMPLATE

Reference Spec Validator Specification:
$SPEC_VALIDATOR_SPEC

Spec to validate:
$SPEC_CONTENT"

# Function to call OpenAI API
call_openai() {
    local model="$1"
    
    # Escape the prompt content using jq to handle newlines and special characters
    local escaped_prompt
    escaped_prompt=$(echo "$FULL_PROMPT" | jq -Rs .)
    
    # Create the request JSON using heredoc
    cat > "$TMP_DIR/request.json" <<EOF
{
  "model": "$model",
  "messages": [
    {
      "role": "system",
      "content": "You are a Spec Validator. Always respond with valid JSON."
    },
    {
      "role": "user",
      "content": $escaped_prompt
    }
  ],
  "temperature": 0.1
}
EOF
    
    local response
    response=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_KEY" \
        -d @"$TMP_DIR/request.json")
    
    # Check for errors
    if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        return 1
    fi
    
    # Extract the content
    local content
    content=$(echo "$response" | jq -r '.choices[0].message.content // empty')
    if [[ -z "$content" ]]; then
        return 1
    fi
    echo "$content"
}

# Function to call Anthropic API
call_anthropic() {
    local model="$1"
    
    # Escape the prompt content using jq
    local escaped_prompt
    escaped_prompt=$(echo "$FULL_PROMPT" | jq -Rs .)
    
    # Create the request JSON using heredoc
    cat > "$TMP_DIR/request.json" <<EOF
{
  "model": "$model",
  "max_tokens": 4096,
  "messages": [
    {
      "role": "user",
      "content": $escaped_prompt
    }
  ]
}
EOF
    
    local response
    response=$(curl -s -X POST https://api.anthropic.com/v1/messages \
        -H "Content-Type: application/json" \
        -H "x-api-key: $API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d @"$TMP_DIR/request.json")
    
    # Check for errors
    if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        return 1
    fi
    
    # Extract the content
    echo "$response" | jq -r '.content[0].text // empty'
}

# Try models in preference order with API-model compatibility check
RESULT=""
MODEL_USED=""

for model in "${MODEL_PREFERENCE[@]}"; do
    # Skip Claude models when using OpenAI API and vice versa
    if [[ "$API_TYPE" == "anthropic" ]] && [[ "$model" == claude* ]]; then
        if RESULT=$(call_anthropic "$model" 2>/dev/null) && [[ -n "$RESULT" ]]; then
            MODEL_USED="$model"
            break
        fi
    elif [[ "$API_TYPE" == "openai" ]] && [[ "$model" == gpt* ]]; then
        if RESULT=$(call_openai "$model" 2>/dev/null) && [[ -n "$RESULT" ]]; then
            MODEL_USED="$model"
            break
        fi
    fi
done

if [[ -z "$RESULT" ]]; then
    error "Failed to get response from API"
fi

# Parse the JSON result
# Strip markdown code blocks from LLM responses before parsing
CLEAN_RESULT=$(echo "$RESULT" | sed -e 's/^```json//' -e 's/^```//' -e 's/```$//')

# Provide fallback JSON structure for parse failures
PARSED_RESULT=$(echo "$CLEAN_RESULT" | jq -c '.' 2>/dev/null || echo '{"status":"FAIL","model_used":"parse_error","summary":{"pass":0,"warn":0,"fail":1},"failures":[{"line":0,"message":"Failed to parse API response"}],"warnings":[],"suggestions":[],"clarifying_questions":[]}')

# Add model_used metadata if not present
if ! echo "$PARSED_RESULT" | jq -e '.model_used' >/dev/null 2>&1; then
    PARSED_RESULT=$(echo "$PARSED_RESULT" | jq --arg model "$MODEL_USED" '. + {model_used: $model}')
fi

# Output results
if [[ "$JSON_OUTPUT" == true ]]; then
    echo "$PARSED_RESULT" | jq '.'
else
    # Human-readable output
    STATUS=$(echo "$PARSED_RESULT" | jq -r '.status')
    MODEL=$(echo "$PARSED_RESULT" | jq -r '.model_used')
    PASS_COUNT=$(echo "$PARSED_RESULT" | jq -r '.summary.pass // 0')
    WARN_COUNT=$(echo "$PARSED_RESULT" | jq -r '.summary.warn // 0')
    FAIL_COUNT=$(echo "$PARSED_RESULT" | jq -r '.summary.fail // 0')
    
    if [[ "$DIFF_MODE" == true ]]; then
        echo -e "[VALIDATION] $ROOT_SPEC_FILE (diff mode)"
    else
        echo -e "[VALIDATION] $SPEC_FILE"
    fi
    echo -e "Status: $STATUS"
    echo -e "Model Used: $MODEL"
    echo
    
    # Failures
    if [[ $(echo "$PARSED_RESULT" | jq -r '.failures | length') -gt 0 ]]; then
        echo -e "${RED}Failures (requires human review):${NC}"
        echo "$PARSED_RESULT" | jq -r '.failures[] | "- Line \(.line): \(.message)"'
        echo
    fi
    
    # Warnings
    if [[ $(echo "$PARSED_RESULT" | jq -r '.warnings | length') -gt 0 ]]; then
        echo -e "${YELLOW}Warnings (agent-fixable):${NC}"
        echo "$PARSED_RESULT" | jq -r '.warnings[] | "- Line \(.line): \(.message)"'
        echo
    fi
    
    # Suggestions
    if [[ $(echo "$PARSED_RESULT" | jq -r '.suggestions | length') -gt 0 ]]; then
        echo -e "Suggestions:"
        echo "$PARSED_RESULT" | jq -r '.suggestions[] | "- [\(.level)] \(.text)"'
        echo
    fi
    
    # Clarifying questions
    if [[ $(echo "$PARSED_RESULT" | jq -r '.clarifying_questions | length') -gt 0 ]]; then
        echo -e "Clarifying Questions:"
        echo "$PARSED_RESULT" | jq -r '.clarifying_questions[] | "- \(.)"'
        echo
    fi
    
    echo -e "Summary:"
    echo -e "${GREEN}PASS: $PASS_COUNT${NC} | ${YELLOW}WARN: $WARN_COUNT${NC} | ${RED}FAIL: $FAIL_COUNT${NC}"
fi

# Exit with appropriate code
STATUS=$(echo "$PARSED_RESULT" | jq -r '.status // "FAIL"')
case "$STATUS" in
    PASS|WARN)
        exit 0
        ;;
    FAIL)
        exit 1
        ;;
    *)
        exit 2
        ;;
esac